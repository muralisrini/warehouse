// Code generated by protoc-gen-go.
// source: events.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Interest_ResponseType int32

const (
	// don't send events (used to cancel interest)
	Interest_DONTSEND Interest_ResponseType = 0
	// send protobuf objects
	Interest_PROTOBUF Interest_ResponseType = 1
	// marshall into JSON byte array
	Interest_JSON Interest_ResponseType = 2
)

var Interest_ResponseType_name = map[int32]string{
	0: "DONTSEND",
	1: "PROTOBUF",
	2: "JSON",
}
var Interest_ResponseType_value = map[string]int32{
	"DONTSEND": 0,
	"PROTOBUF": 1,
	"JSON":     2,
}

func (x Interest_ResponseType) String() string {
	return proto.EnumName(Interest_ResponseType_name, int32(x))
}

type Interest struct {
	EventType    string                `protobuf:"bytes,1,opt,name=eventType" json:"eventType,omitempty"`
	ResponseType Interest_ResponseType `protobuf:"varint,2,opt,name=responseType,enum=protos.Interest_ResponseType" json:"responseType,omitempty"`
}

func (m *Interest) Reset()         { *m = Interest{} }
func (m *Interest) String() string { return proto.CompactTextString(m) }
func (*Interest) ProtoMessage()    {}

// ---------- consumer events ---------
// Register is sent by consumers for registering events
// string type - "register"
type Register struct {
	Events []*Interest `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
}

func (m *Register) Reset()         { *m = Register{} }
func (m *Register) String() string { return proto.CompactTextString(m) }
func (*Register) ProtoMessage()    {}

func (m *Register) GetEvents() []*Interest {
	if m != nil {
		return m.Events
	}
	return nil
}

// ---------- producer events ---------
// Generic is used for encoding payload as JSON or raw bytes
// string type - "generic"
type Generic struct {
	EventType string `protobuf:"bytes,1,opt,name=eventType" json:"eventType,omitempty"`
	Payload   []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Generic) Reset()         { *m = Generic{} }
func (m *Generic) String() string { return proto.CompactTextString(m) }
func (*Generic) ProtoMessage()    {}

// OpenchainEvent is used by
//  - consumers (adapters) to send Register
//  - producer to advertise supported types and events
type OpenchainEvent struct {
	// TODO need timestamp
	//
	// Types that are valid to be assigned to Event:
	//	*OpenchainEvent_Register
	//	*OpenchainEvent_Block
	//	*OpenchainEvent_Generic
	Event isOpenchainEvent_Event `protobuf_oneof:"Event"`
}

func (m *OpenchainEvent) Reset()         { *m = OpenchainEvent{} }
func (m *OpenchainEvent) String() string { return proto.CompactTextString(m) }
func (*OpenchainEvent) ProtoMessage()    {}

type isOpenchainEvent_Event interface {
	isOpenchainEvent_Event()
}

type OpenchainEvent_Register struct {
	Register *Register `protobuf:"bytes,1,opt,name=register,oneof"`
}
type OpenchainEvent_Block struct {
	Block *Block `protobuf:"bytes,2,opt,name=block,oneof"`
}
type OpenchainEvent_Generic struct {
	Generic *Generic `protobuf:"bytes,3,opt,name=generic,oneof"`
}

func (*OpenchainEvent_Register) isOpenchainEvent_Event() {}
func (*OpenchainEvent_Block) isOpenchainEvent_Event()    {}
func (*OpenchainEvent_Generic) isOpenchainEvent_Event()  {}

func (m *OpenchainEvent) GetEvent() isOpenchainEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *OpenchainEvent) GetRegister() *Register {
	if x, ok := m.GetEvent().(*OpenchainEvent_Register); ok {
		return x.Register
	}
	return nil
}

func (m *OpenchainEvent) GetBlock() *Block {
	if x, ok := m.GetEvent().(*OpenchainEvent_Block); ok {
		return x.Block
	}
	return nil
}

func (m *OpenchainEvent) GetGeneric() *Generic {
	if x, ok := m.GetEvent().(*OpenchainEvent_Generic); ok {
		return x.Generic
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OpenchainEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _OpenchainEvent_OneofMarshaler, _OpenchainEvent_OneofUnmarshaler, []interface{}{
		(*OpenchainEvent_Register)(nil),
		(*OpenchainEvent_Block)(nil),
		(*OpenchainEvent_Generic)(nil),
	}
}

func _OpenchainEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OpenchainEvent)
	// Event
	switch x := m.Event.(type) {
	case *OpenchainEvent_Register:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Register); err != nil {
			return err
		}
	case *OpenchainEvent_Block:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case *OpenchainEvent_Generic:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Generic); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OpenchainEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _OpenchainEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OpenchainEvent)
	switch tag {
	case 1: // Event.register
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Register)
		err := b.DecodeMessage(msg)
		m.Event = &OpenchainEvent_Register{msg}
		return true, err
	case 2: // Event.block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Block)
		err := b.DecodeMessage(msg)
		m.Event = &OpenchainEvent_Block{msg}
		return true, err
	case 3: // Event.generic
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Generic)
		err := b.DecodeMessage(msg)
		m.Event = &OpenchainEvent_Generic{msg}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterEnum("protos.Interest_ResponseType", Interest_ResponseType_name, Interest_ResponseType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for OpenchainEvents service

type OpenchainEventsClient interface {
	// event chatting using OpenchainEvent
	Chat(ctx context.Context, opts ...grpc.CallOption) (OpenchainEvents_ChatClient, error)
}

type openchainEventsClient struct {
	cc *grpc.ClientConn
}

func NewOpenchainEventsClient(cc *grpc.ClientConn) OpenchainEventsClient {
	return &openchainEventsClient{cc}
}

func (c *openchainEventsClient) Chat(ctx context.Context, opts ...grpc.CallOption) (OpenchainEvents_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OpenchainEvents_serviceDesc.Streams[0], c.cc, "/protos.OpenchainEvents/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &openchainEventsChatClient{stream}
	return x, nil
}

type OpenchainEvents_ChatClient interface {
	Send(*OpenchainEvent) error
	Recv() (*OpenchainEvent, error)
	grpc.ClientStream
}

type openchainEventsChatClient struct {
	grpc.ClientStream
}

func (x *openchainEventsChatClient) Send(m *OpenchainEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *openchainEventsChatClient) Recv() (*OpenchainEvent, error) {
	m := new(OpenchainEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OpenchainEvents service

type OpenchainEventsServer interface {
	// event chatting using OpenchainEvent
	Chat(OpenchainEvents_ChatServer) error
}

func RegisterOpenchainEventsServer(s *grpc.Server, srv OpenchainEventsServer) {
	s.RegisterService(&_OpenchainEvents_serviceDesc, srv)
}

func _OpenchainEvents_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OpenchainEventsServer).Chat(&openchainEventsChatServer{stream})
}

type OpenchainEvents_ChatServer interface {
	Send(*OpenchainEvent) error
	Recv() (*OpenchainEvent, error)
	grpc.ServerStream
}

type openchainEventsChatServer struct {
	grpc.ServerStream
}

func (x *openchainEventsChatServer) Send(m *OpenchainEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *openchainEventsChatServer) Recv() (*OpenchainEvent, error) {
	m := new(OpenchainEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _OpenchainEvents_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.OpenchainEvents",
	HandlerType: (*OpenchainEventsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _OpenchainEvents_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
